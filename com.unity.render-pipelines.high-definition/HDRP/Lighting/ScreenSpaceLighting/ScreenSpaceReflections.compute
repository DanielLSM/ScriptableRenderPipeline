#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

//#pragma enable_d3d11_debug_symbols

// -------------------------------------------------
// Screen Space Reflection
// -------------------------------------------------
// Proxy passes
// 1. Cast Rays
// 2. Resolve color
//
// Raytracing passes
// 1. Clear buffers
// 2. Allocate rays
// 3. Cast rays
// 4. Resolve color
// -------------------------------------------------

#define PASS_CLEAR 0
#define PASS_CAST_RAYS 1
#define PASS_ALLOCATE_RAYS 2
#define PASS_RESOLVE 3

// -------------------------------------------------
// Kernels Settings
// -------------------------------------------------
// Kernel settings
#define GROUP_SIZE_1D 8
#define GROUP_SIZE_2D (GROUP_SIZE_1D * GROUP_SIZE_1D)
#define WAVEFRONT_SIZE 64

#if PASS == PASS_CLEAR
#elif PASS == PASS_CAST_RAYS
#elif PASS == PASS_ALLOCATE_RAYS
    #define USE_COMPRESSED_BAYER4
#endif

// -------------------------------------------------
// Kernels
// -------------------------------------------------
#pragma kernel KClear                       KNAME=KClear                    PASS=PASS_CLEAR
#pragma kernel KAllocateRays_HiZ            KNAME=KAllocateRays_HiZ         PASS=PASS_ALLOCATE_RAYS
#pragma kernel KAllocateRays_Debug_HiZ      KNAME=KAllocateRays_Debug_HiZ   PASS=PASS_ALLOCATE_RAYS     DEBUG_DISPLAY
#pragma kernel KCastRays_HiZ                KNAME=KCastRays_HiZ             PASS=PASS_CAST_RAYS
#pragma kernel KCastRays_Debug_HiZ          KNAME=KCastRays_Debug_HiZ       PASS=PASS_CAST_RAYS         DEBUG_DISPLAY
#pragma kernel KResolve                     KNAME=KResolve                  PASS=PASS_RESOLVE

// -------------------------------------------------
// Common includes of passes
// -------------------------------------------------
#include "CoreRP/ShaderLibrary/Common.hlsl"
#include "CoreRP/ShaderLibrary/SpaceFillingCurves.hlsl"
#include "CoreRP/ShaderLibrary/Debug.hlsl"

#include "HDRP/ShaderVariables.hlsl"
#ifdef DEBUG_DISPLAY
#include "HDRP/Debug/DebugDisplay.hlsl"
#endif
#define UNITY_MATERIAL_LIT // Need to be define before including Material.hlsl
#include "HDRP/Material/Material.hlsl" // This will include #include "ScreenSpaceLighting.hlsl" with Lit.hlsl

// -------------------------------------------------
// Variable
// -------------------------------------------------

TEXTURE2D(_SSReflectionRayHitTexture);

// -------------------------------------------------
// Common
// -------------------------------------------------
struct AllocationPayload
{
    uint2 positionSS;
};

uint EncodeAllocationPayload(AllocationPayload payload)
{
    return (payload.positionSS.x & 0xFFFF) | (payload.positionSS.y << 16);
}

AllocationPayload DecodeAllocationPayload(uint payload)
{
    AllocationPayload result;
    result.positionSS.x = (payload & 0xFFFF);
    result.positionSS.y = payload >> 16;
    return result;
}

uint GetIndex(uint2 groupId, uint groupThreadId)
{
    uint groupPerRow = uint(ceil(_ScreenSize.x / GROUP_SIZE_1D));
    return groupThreadId + (groupId.y * groupPerRow + groupId.x) * GROUP_SIZE_2D + 3;
}

// #################################################
// Pass: Clear
// #################################################
// Clear buffers
// -------------------------------------------------
#if PASS == PASS_CLEAR

RWBuffer<uint>      _PayloadIndirect;

[numthreads(1, 1, 1)]
void KNAME(
    uint2 groupId           : SV_GroupID,
    uint  groupThreadId     : SV_GroupThreadID
)
{
    // Clear allocated dispatch indirect buffer
    _PayloadIndirect[0] = 0;
    _PayloadIndirect[1] = 1;
    _PayloadIndirect[2] = 1;
}

// #################################################
// Pass: Allocate Rays
// #################################################
// HiZ only
// Calculate initialization values for HiZ algorithm
// -------------------------------------------------
#elif PASS == PASS_ALLOCATE_RAYS

RWBuffer<uint>                  _PayloadIndirect;
RWBuffer<uint>                  _Payload;  // Indirect argument must be in Buffer
RWStructuredBuffer<float4>      _Payload1; // Must use a StructuredBuffer here otherwise, swizzlign is incorrect for PS4
RWStructuredBuffer<float4>      _Payload2; // Must use a StructuredBuffer here otherwise, swizzlign is incorrect for PS4

#ifdef DEBUG_DISPLAY
RW_TEXTURE2D(float4,        _DebugTexture);
#endif

// -------------------------------------------------
// Entry point: Allocate Rays
// -------------------------------------------------
[numthreads(GROUP_SIZE_2D, 1, 1)]
void KNAME(
    uint2 groupId           : SV_GroupID,
    uint  groupThreadId     : SV_GroupThreadID
)
{
    if (groupThreadId == 0)
        InterlockedAdd(_PayloadIndirect[0], 1);

    groupThreadId &= GROUP_SIZE_2D - 1;

    uint groupPerRow            = uint(ceil(float(uint(_ScreenSize.x) >> _SSReflectionMipResolution) / GROUP_SIZE_1D));
    uint index                  = groupThreadId + (groupId.y * groupPerRow + groupId.x) * GROUP_SIZE_2D;
    uint2 groupCoord            = groupId * GROUP_SIZE_1D;
    uint2 groupThreadCoord      = DecodeMorton2D(groupThreadId);
    uint2 positionTXS           = groupCoord + groupThreadCoord;
    uint2 positionSS            = positionTXS << _SSReflectionMipResolution;
    float2 positionNDC          = (positionSS + float2(0.5, 0.5)) * _ScreenSize.zw;

    // Decode Buffer
    float deviceDepth           = LOAD_TEXTURE2D(_CameraDepthTexture, positionSS.xy).x;
    float3 positionWS           = ComputeWorldSpacePosition(positionNDC, deviceDepth, UNITY_MATRIX_I_VP);
    float3 V                    = GetWorldSpaceNormalizeViewDir(positionWS);

    // Get normal and roughness from normalBuffer
    NormalData normalData;
    DecodeFromNormalBuffer(positionSS, normalData);
    float3 normalWS = normalData.normalWS;
    float perceptualRoughness = normalData.perceptualRoughness;

    // Calculate ray endpoints
    float3 rayOriginWS          = positionWS;
    float3 rayDirWS             = reflect(-V, normalWS);

    float3 startPositionSS;
    float3 endPositionSS;
    CalculateRayEndPointSS(
        rayOriginWS + rayDirWS * SampleBayer4(positionSS + uint2(_FrameCount, uint(_FrameCount) / 4u)) * 0.1,
        rayDirWS,
        uint2(_DepthPyramidSize.xy),
        startPositionSS,
        endPositionSS
    );

    // Save payload
    AllocationPayload allocationPayload;
    allocationPayload.positionSS = positionSS;

    _Payload[index]             = EncodeAllocationPayload(allocationPayload);
    _Payload1[index]            = float4(startPositionSS, perceptualRoughness);
    _Payload2[index]            = float4(endPositionSS, 1);
}

// #################################################
// Pass: Cast Rays
// #################################################
// Cast rays in screen space and store the hit in a buffer
// -------------------------------------------------
#elif PASS == PASS_CAST_RAYS

// Resources
RW_TEXTURE2D(uint4,         _SSReflectionRayHitNextTexture);
#ifdef DEBUG_DISPLAY
RW_TEXTURE2D(float4,        _DebugTexture);
#endif

Buffer<uint>                _Payload;
StructuredBuffer<float4>    _Payload1; // Must use a StructuredBuffer here otherwise, swizzlign is incorrect for PS4
StructuredBuffer<float4>    _Payload2; // Must use a StructuredBuffer here otherwise, swizzlign is incorrect for PS4
Texture2D<uint4>            _SSReflectionRayAllocationTexture;

[numthreads(GROUP_SIZE_2D, 1, 1)]
void KNAME(
    uint dispatchThreadID : SV_DispatchThreadID
)
{
    uint index                      = dispatchThreadID;
    
    // Read allocation payload
    AllocationPayload allocation    = DecodeAllocationPayload(_Payload[index]);
    uint2 positionSS                = allocation.positionSS;
    uint2 positionTXS               = positionSS >> _SSReflectionMipResolution;
    float3 startRayPositionSS       = _Payload1[index].xyz;
    float perceptualRoughness       = _Payload1[index].w;
    float3 endRayPositionSS         = _Payload2[index].xyz;
    float3 raySS                    = endRayPositionSS - startRayPositionSS;

    // Screen space tracing query
    ScreenSpaceRayHit hit;
    ZERO_INITIALIZE(ScreenSpaceRayHit, hit);
    bool hitSuccessful              = false;
    float hitWeight                 = 1;

    ScreenSpaceRaymarchInputPrecomputed ssRayInput;
    ssRayInput.startPositionSS      = startRayPositionSS;
    ssRayInput.raySS                = raySS;
#ifdef DEBUG_DISPLAY
    ssRayInput.debug                = _DebugLightingMode == DEBUGLIGHTINGMODE_SCREEN_SPACE_TRACING_REFLECTION
                                    && !any(int2(_MouseClickPixelCoord.xy) - int2(allocation.positionSS));
#endif

    hitSuccessful = ScreenSpaceHiZRaymarchPrecomputedReflection(ssRayInput, hit, hitWeight);

    uint4 outputPayload = uint4(0, 0, 0, 0);
    EncodeRayHit(hit.positionSS, hit.positionNDC, hitWeight, hitSuccessful, perceptualRoughness, outputPayload);

    _SSReflectionRayHitNextTexture[positionTXS] = outputPayload;
#ifdef DEBUG_DISPLAY
    _DebugTexture[positionSS] = float4(hit.debugOutput, 1);
#endif
}


// #################################################
// Pass: Resolve
// #################################################
// Resolve the color in a specific buffer
// -------------------------------------------------
#elif PASS == PASS_RESOLVE

// Resources
Texture2D<uint4>            _SSReflectionRayHitNextTexture;
RW_TEXTURE2D(float4,        _SSReflectionResolveNextTexture);
#ifdef DEBUG_DISPLAY
RW_TEXTURE2D(float4,        _DebugTexture);
#endif

[numthreads(GROUP_SIZE_2D, 1, 1)]
void KNAME(
    uint2 groupId           : SV_GroupID,
    uint  groupThreadId     : SV_GroupThreadID
)
{
    uint groupPerRow            = uint(ceil(float(uint(_ScreenSize.x) >> _SSReflectionMipResolution) / GROUP_SIZE_1D));
    uint index                  = groupThreadId + (groupId.y * groupPerRow + groupId.x) * GROUP_SIZE_2D;
    uint2 groupCoord            = groupId * GROUP_SIZE_1D;
    uint2 groupThreadCoord      = DecodeMorton2D(groupThreadId);
    uint2 positionTXS           = groupCoord + groupThreadCoord;
    uint2 positionSS            = positionTXS << _SSReflectionMipResolution;
    float perceptualRoughness   = 0;
    uint2 hitPositionSS         = uint2(0, 0);
    float2 hitPositionNDC       = float2(0, 0);
    float hitWeight             = 0;
    bool hitSuccessful          = false;
    
    uint4 payload = asuint(LOAD_TEXTURE2D_LOD(_SSReflectionRayHitTexture, positionTXS, 0));
    DecodeRayHit(payload, hitPositionSS, hitPositionNDC, hitWeight, hitSuccessful, perceptualRoughness);

    int mipLevel = PlanarPerceptualRoughnessToMipmapLevel(perceptualRoughness, _ColorPyramidScale.z);

    float weight = CalculateFullWeight(hitPositionNDC, _SSReflectionInvScreenWeightDistance, hitWeight, hitSuccessful);

    if (weight == 0)
    {
        _SSReflectionResolveNextTexture[positionTXS] = 0;
        return;
    }

    // Reproject color pyramid
    float4 color = float4(0, 0, 0, 0);
    {
        float4 hitVelocityBuffer = LOAD_TEXTURE2D_LOD(
            _CameraMotionVectorsTexture,
            hitPositionSS,
            0.0
        );

        float2 hitVelocityNDC;
        DecodeVelocity(hitVelocityBuffer, hitVelocityNDC);

        color = SAMPLE_TEXTURE2D_LOD(
            _ColorPyramidTexture,
            s_trilinear_clamp_sampler,
            // Offset by half a texel to properly interpolate between this pixel and its mips
            (hitPositionNDC - hitVelocityNDC) * _ColorPyramidScale.xy + _ColorPyramidSize.zw * 0.5,
            mipLevel
        );
    }
    
    // With HiZ, we use a temporal filtering to reduce the noise from the ray origin jittering
    {
        float temporalFilteringWeight   = 0.1;
        float4 currentVelocityBuffer = LOAD_TEXTURE2D_LOD(
            _CameraMotionVectorsTexture,
            positionSS,
            0.0
        );

        float2 currentVelocityNDC;
        DecodeVelocity(currentVelocityBuffer, currentVelocityNDC);

        float4 currentLD = LOAD_TEXTURE2D_LOD(
            _ColorPyramidTexture,
            int2(positionSS) - int2(currentVelocityNDC * _ScreenSize.xy),
            0
        );
        color = color * (1.0 - temporalFilteringWeight) + currentLD * temporalFilteringWeight;
    }

    color.a = weight;

#ifdef DEBUG_DISPLAY
    if (_DebugLightingMode == DEBUGLIGHTINGMODE_SCREEN_SPACE_TRACING_REFLECTION)
    {
        bool applyDebug = true;
        float4 debugColor = 0;
        switch (_DebugLightingSubMode)
        {
            case DEBUGSCREENSPACETRACING_HIT_SUCCESS:
                debugColor = float4(1, hitSuccessful ? 1 : 0, 0, 1);
                break;
            case DEBUGSCREENSPACETRACING_HI_ZHIT_WEIGHT:
                debugColor = float4(hitWeight, hitWeight, hitWeight, 1);
                break;
            case DEBUGSCREENSPACETRACING_HI_ZPOSITION_NDC:
                debugColor = float4(hitPositionNDC.x, hitPositionNDC.y, 0.5, 1);
                break;
            default:
                applyDebug = false;
                break;
        }

        // if (applyDebug)
        //     _DebugTexture[positionSS] = debugColor;
    }
#endif

    _SSReflectionResolveNextTexture[positionTXS] = color;
}

#endif
